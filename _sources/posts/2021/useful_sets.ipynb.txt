{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Useful things you can do with Sets in Python\n",
    "Perhaps Python's most underrated built-in"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## I don't use Sets as often as I should\n",
    "I have noticed that everytime I need to create a collection/data structure in Python, I almost always default to:\n",
    "- a list (about 90% of the time)\n",
    "- a numpy array (when I'm thinking about speed)\n",
    "- a dictionary (when I want a hashmap)\n",
    "\n",
    "And I don't think about using Sets as much as I really should, which is a real pity because Sets are a very special and powerful Python built-in type that can solve many common problems. So here's short little blog post on some useful things you can do with Sets."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "```{image} /images/undraw_sorting_thoughts.png\n",
    ":align: center\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Removing duplicate elements\n",
    "A set can only contain unique elements, and this property makes sets a very convenient data structure for removing duplicates. \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{'Peter', 'Jay', 'Russ', 'Andy', 'Bob'}\n"
     ]
    }
   ],
   "source": [
    "names = [\"Andy\", \"Bob\", \"Andy\", \"Jay\", \"Peter\", \"Bob\", \"Russ\", \"Jay\"]\n",
    "unique_names = set(names)\n",
    "print(unique_names)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "It is common to apply the `set()` function on a Python iterable, such as a `List` (ie. example above) or a `Tuple`, but don't forget that `String` is also an iterable type in Python! This means we can also use sets to find the unique letters in any given string."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{'o', 'g', 's', 'd', 't', 'l', 'e', 'a', 'f', 'x', 'u', 'i', 'r', 'c', 'p'}\n"
     ]
    }
   ],
   "source": [
    "long_string = \"supercalifragilisticexpialidocious\"\n",
    "unique_letters = set(long_string)\n",
    "print(unique_letters)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Set Theory\n",
    "The concept of a Set in Python comes from [Set Theory](https://en.wikipedia.org/wiki/Set_theory), which is a foundational branch of Mathematics that teaches us how we can think about collections of objects or numbers. Probably, Set Theory was your 1st introduction to the famous Venn Diagram, and it's related concepts such as Unions and Intersections. Just like what we learnt in Math class, we can perform the following useful operations on 2 or more Python Sets."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Union\n",
    "Join 2 or more Sets and return the non-duplicated results"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{'tulips', 'daisies', 'hydrangeas', 'orchids', 'lilies', 'roses', 'chrysanthemums'}\n"
     ]
    }
   ],
   "source": [
    "garden1 = set(['tulips', 'hydrangeas', 'roses', 'chrysanthemums'])\n",
    "garden2 = set(['chrysanthemums','lilies','orchids','hydrangeas'])\n",
    "garden3 = set(['roses','lilies', 'daisies'])\n",
    "\n",
    "unique_flowers = garden1.union(garden2,garden3)\n",
    "print(unique_flowers)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Intersection\n",
    "Return only the common elements in 2 or more Sets"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{34, 22}\n"
     ]
    }
   ],
   "source": [
    "# Each group contains a list of customer_ids\n",
    "group_a = set([121, 34, 156, 22, 95, 61])\n",
    "group_b = set([34, 156, 31, 24, 53, 99, 22])\n",
    "group_c = set([24, 99, 84, 22, 14, 34, 53])\n",
    "\n",
    "common_customer_ids = group_a.intersection(group_b, group_c)\n",
    "print(common_customer_ids)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "```{admonition} Simple is better than Complex\n",
    ":class: tip\n",
    "Looking back at my old code, there are so many occasions where I used more complex methods, such as merging 2 DataFrames with an inner join, to find an intersecting elements. \n",
    "\n",
    "In many cases, we are better served by using the much simpler approach of calling the intersection method between 2 sets instead.\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Difference\n",
    "Return only the non-common elements between 2 or more sets"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{'Haskell', 'Golang', 'C++'}\n"
     ]
    }
   ],
   "source": [
    "languages1 = set(['Python','C++','Golang','Haskell', 'R'])\n",
    "languages2 = set(['R', 'Javascript', 'Python', 'Julia', 'Erlang'])\n",
    "\n",
    "non_common_languages = languages1.difference(languages2)\n",
    "print(non_common_languages)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Conditional Checks\n",
    "I also categorize several Set methods under the purpose of performing some type of conditional check and returning either a True or False boolean. These are particularly useful and fast operations to add to long scripts or unit tests."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Isdisjoint\n",
    "Returns True if no elements between 2 Sets are common, and False if there is at least 1 common element."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "colours1 = set(['red', 'yellow', 'green'])\n",
    "colours2 = set(['blue', 'purple', 'lilac'])\n",
    "\n",
    "colours1.isdisjoint(colours2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "colours3 = set(['red', 'yellow', 'green', 'rainbow'])\n",
    "colours4 = set(['blue', 'purple', 'lilac', 'rainbow'])\n",
    "\n",
    "colours3.isdisjoint(colours4)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Issubset and Issuperset\n",
    "\n",
    "In this signature `primary.method(secondary)`:\n",
    "\n",
    "Issubset returns True if all the elements of the primary set are members of the secondary set, returns False otherwise.\n",
    "\n",
    "Issuperset returns True if all the elements of the secondary set are members of the primary set, return False otherwise."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 17,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "primary = set(['a','b'])\n",
    "secondary = set(['a','b','c','d'])\n",
    "\n",
    "primary.issubset(secondary)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "primary = set(['x','y','z'])\n",
    "secondary = set(['x','y'])\n",
    "\n",
    "primary.issuperset(secondary)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Special use cases\n",
    "Lastly, there are a lot of special use cases that are neat and novels ways to use Sets. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Speedy check for membership\n",
    "Under the hood, sets are implemented using hash tables. This means when we want to check if an element is a member of a set (ie. lookup), this operation is faster versus a similar membership check in a list.\n",
    "\n",
    "Source: https://stackoverflow.com/questions/8929284/what-makes-sets-faster-than-lists/8929445\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "big_list = range(10**8)\n",
    "big_set = set(range(10**8))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The slowest run took 15.21 times longer than the fastest. This could mean that an intermediate result is being cached.\n",
      "10000000 loops, best of 5: 71.2 ns per loop\n"
     ]
    }
   ],
   "source": [
    "%%timeit\n",
    "1612 in big_list"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "10000000 loops, best of 5: 35.5 ns per loop\n"
     ]
    }
   ],
   "source": [
    "%%timeit\n",
    "1612 in big_set"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Budget load balancer\n",
    "1 of Set's properties is that it's elements are always unordered, and this is usually seen as a disadvantage. In fact, it's surprising that Set actually has a `pop()` method that is usually reserved for ordered data structures. When you call `pop()` on a set, it removes a random element. I used to think that was a pretty useless method, until I read this [StackOverflow post](https://stackoverflow.com/questions/19378718/python-whats-the-use-case-for-set-pop).\n",
    "\n",
    "Amusingly, this random removal of an element works surprisingly well to create a simple load balancer."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Processing job2\n",
      "Processing job1\n",
      "Processing job3\n",
      "Processing job4\n",
      "Processing job5\n",
      "\n",
      "Jobs done!\n"
     ]
    }
   ],
   "source": [
    "jobs = set(['job1', 'job2', 'job3','job4','job5'])\n",
    "\n",
    "while jobs:\n",
    "    current_job = jobs.pop()\n",
    "    print(f'Processing {current_job}')\n",
    "\n",
    "print('\\nJobs done!')"
   ]
  }
 ],
 "metadata": {
  "date": "2021-04-27",
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  },
  "tags": "",
  "title": "Useful things you can do with Sets in Python"
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
